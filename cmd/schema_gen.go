// TODO;

// helpers
// - YML encoder helper (Unmarshal already exists)
// - Search for model relating to passed model name, if not present throw error
// - if present search for yml file of the same name

// generate file
// - if not found generate whole yml file
// - if found parse yml to Go Struct
// - get big query table - zero rows but with column names
// - iterate through column names and add to YML struct (if not in file already)
// - iterate through yml struct and if names not in schema remove them
// - finally marshall
// - useful logging at each step

package cmd

import (
	"ddbt/bigquery"
	"ddbt/config"
	"ddbt/properties"

	"fmt"
	"os"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

func init() {
	rootCmd.AddCommand(schemaGenCmd)
}

var schemaGenCmd = &cobra.Command{
	Use:   "schema_gen [model name]",
	Short: "Generates the YML schema file for a given model",
	Args:  cobra.ExactValidArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		modelName := args[0]
		fileSystem, _ := compileAllModels()
		model := fileSystem.Model(modelName)

		target, err := model.GetTarget()
		if err != nil {
			fmt.Println("could not get target for schema")
			os.Exit(1)
		}
		fmt.Println("üéØ Target for retrieving schema:", target.ProjectID+"."+target.DataSet)

		bqColumns, err := GetColumnsForModel(modelName, target)
		if err != nil {
			fmt.Println("Could not retrieve schema")
			os.Exit(1)
		}
		fmt.Println("‚úÖ BQ Schema retrieved. Number of columns in BQ table:", len(bqColumns))

		// get schema path to write the schema yml file to
		ymlPath := strings.Replace(model.Path, ".sql", ".yml", 1)

		schemaFile := properties.File{}
		schemaFile.Version = properties.FileVersion

		if model.Schema == nil {
			fmt.Println("üîç " + modelName + " schema file not found.. üå± Generating new schema file (Not implemented)")

			schemaModel := properties.Model{}
			schemaModel.Name = modelName
			schemaModel.Description = "Please fill this in with a useful description.."

			schemaModel.Columns = []properties.Column{}
			for _, bqCol := range bqColumns {
				column := properties.Column{}
				column.Name = bqCol
				schemaModel.Columns = append(schemaModel.Columns, column)
			}

			schemaFile.Models = properties.Models{&schemaModel}

			ymlBody := marshalYML(schemaFile)
			err = WriteYMLToFile(ymlPath, ymlBody)
			if err != nil {
				fmt.Println("Error writing YML to file in path")
				os.Exit(1)
			}
			fmt.Println("‚úÖ " + modelName + "schema successfully written to path: " + ymlPath)

		} else {
			fmt.Println("üîç " + modelName + " schema file found.. üõ†  Updating schema file (Not implemented)")
			// spew.Dump(model.Schema)
			schemaModel := model.Schema

			// check if bq column is in schema (add missing)
			columnsAdded := []string{}
			for _, bqCol := range bqColumns {
				columnFound := FindColumnInSchema(bqCol, schemaModel)
				if !columnFound {
					column := properties.Column{}
					column.Name = bqCol
					schemaModel.Columns = append(schemaModel.Columns, column)
					columnsAdded = append(columnsAdded, bqCol)
				}
			}
			fmt.Println("‚ûï Columns added to Schema (from BQ table):", columnsAdded)

			// check if schema column in bq (remove missing)
			columnsRemoved := []string{}
			columnsKept := properties.Columns{}
			for _, schemaCol := range schemaModel.Columns {
				columnFound := FindSchemaColumnInSlice(schemaCol, bqColumns)
				if !columnFound {
					columnsRemoved = append(columnsRemoved, schemaCol.Name)
				} else {
					columnsKept = append(columnsKept, schemaCol)
				}
			}
			schemaModel.Columns = columnsKept
			fmt.Println("‚ûñ Columns removed from Schema (no longer in BQ table):", columnsRemoved)

			yml := marshalYML(schemaModel)
			fmt.Println(yml)
		}

	},
}

func marshalYML(schema interface{}) string {
	y, err := yaml.Marshal(&schema)
	if err != nil {
		fmt.Println("Could not marshal schema")
	}
	yml := fmt.Sprintf("\n%s\n\n", string(y))
	return yml
}

func GetColumnsForModel(modelName string, target *config.Target) ([]string, error) {
	schema, err := bigquery.GetColumnsFromTable(modelName, target)
	if err != nil {
		return nil, err
	}

	columns := []string{}
	for _, FieldSchema := range schema {
		column := fmt.Sprintf("%v", FieldSchema.Name)
		columns = append(columns, column)
	}
	return columns, nil
}

func WriteYMLToFile(filePath string, body string) error {
	f, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer f.Close()

	_, _ = f.WriteString("# Auto-generated by DDBT at " + time.Now().String())
	_, err = f.WriteString(body)
	if err != nil {
		return err
	}
	return nil
}

func FindColumnInSchema(column string, schema *properties.Model) bool {
	for _, schemacol := range schema.Columns {
		if schemacol.Name == column {
			return true
		}
	}
	return false
}

func FindSchemaColumnInSlice(column properties.Column, columnSlice []string) bool {
	for _, col := range columnSlice {
		if column.Name == col {
			return true
		}
	}
	return false
}

func removeColumnIndex(slice []properties.Column, s int) []properties.Column {
	return append(slice[:s], slice[s+1:]...)
}
